const crypto = require('crypto');
const encryptionService = require('./encryptionService');
const systemAuditService = require('./systemAuditService');

class TriggerService {
    constructor() {
        this.auditColumns = [
            'usuario_accion',
            'fecha_accion',
            'accion_sql',
            'id_audit'
        ];
    }

    // Obtener estructura de columnas para MySQL
    async getMySQLColumns(connection, database, tableName) {
        const query = `
            SELECT column_name, column_type, is_nullable, column_default, column_key, extra
            FROM information_schema.columns 
            WHERE table_schema = ? AND table_name = ? 
            ORDER BY ordinal_position
        `;

        const [rows] = await connection.execute(query, [database, tableName]);
        return rows.map(row => ({
            name: row.column_name,
            type: row.column_type,
            nullable: row.is_nullable === 'YES',
            defaultValue: row.column_default,
            isPrimaryKey: row.column_key === 'PRI',
            isAutoIncrement: row.extra === 'auto_increment'
        }));
    }

    // Obtener estructura de columnas para PostgreSQL
    async getPostgreSQLColumns(connection, schema, tableName) {
        const query = `
            SELECT 
                c.column_name, 
                c.data_type, 
                c.character_maximum_length, 
                c.is_nullable, 
                c.column_default,
                tc.constraint_type
            FROM information_schema.columns c
            LEFT JOIN information_schema.key_column_usage kcu 
                ON c.table_name = kcu.table_name AND c.column_name = kcu.column_name AND c.table_schema = kcu.table_schema
            LEFT JOIN information_schema.table_constraints tc 
                ON kcu.constraint_name = tc.constraint_name AND tc.constraint_type = 'PRIMARY KEY'
            WHERE c.table_schema = $1 AND c.table_name = $2 
            ORDER BY c.ordinal_position
        `;

        const client = await connection.connect();
        try {
            const result = await client.query(query, [schema, tableName]);
            return result.rows.map(row => ({
                name: row.column_name,
                type: this.mapPostgreSQLType(row.data_type, row.character_maximum_length),
                nullable: row.is_nullable === 'YES',
                defaultValue: row.column_default,
                isPrimaryKey: row.constraint_type === 'PRIMARY KEY'
            }));
        } finally {
            client.release();
        }
    }

    // CORREGIR: Generar nombres de columnas encriptadas consistentes
    generateEncryptedColumnName(columnName, encryptionKey) {
        // Usar un hash determin√≠stico para generar nombres consistentes
        const hash = crypto
            .createHash('sha256')
            .update(columnName + encryptionKey)
            .digest('hex')
            .substring(0, 12);

        return `enc_${hash}`;
    }

    // Crear tabla de auditor√≠a encriptada para PostgreSQL - CORREGIDO
    async createPostgreSQLAuditTable(connection, schema, tableName, encryptionKey) {
        try {
            // Validar clave de encriptaci√≥n
            encryptionService.validateEncryptionKey(encryptionKey);

            const columns = await this.getPostgreSQLColumns(connection, schema, tableName);

            // CORREGIR: Generar nombres de columnas encriptadas de forma determin√≠stica
            const encryptedColumns = columns.map(col => {
                const encryptedName = this.generateEncryptedColumnName(col.name, encryptionKey);
                return `${encryptedName} TEXT`;
            });

            // Agregar columnas de auditor√≠a encriptadas
            const auditCols = this.auditColumns.map(col => {
                const encryptedName = this.generateEncryptedColumnName(col, encryptionKey);
                return `${encryptedName} TEXT`;
            });

            const allColumns = [
                'id_audit_enc SERIAL PRIMARY KEY',
                'created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP',
                ...encryptedColumns,
                ...auditCols
            ];

            const auditTableName = `aud_${tableName}`;

            console.log('üîß Creando tabla con columnas:', allColumns);

            const client = await connection.connect();
            try {
                // Eliminar tabla existente si existe
                await client.query(`DROP TABLE IF EXISTS "${schema}"."${auditTableName}" CASCADE`);

                // Crear nueva tabla
                const createTableSQL = `
                    CREATE TABLE "${schema}"."${auditTableName}" (
                        ${allColumns.join(',\n                        ')}
                    )
                `;

                console.log('üîß SQL de creaci√≥n de tabla:', createTableSQL);

                await client.query(createTableSQL);

                console.log(`‚úÖ Tabla de auditor√≠a PostgreSQL creada: ${auditTableName}`);

                await systemAuditService.logAuditConfig(
                    'POSTGRESQL_AUDIT_TABLE_CREATED',
                    tableName,
                    'system',
                    { auditTableName, encryptionEnabled: true }
                );

                return { success: true, auditTableName };
            } finally {
                client.release();
            }
        } catch (error) {
            console.error('‚ùå Error creando tabla de auditor√≠a PostgreSQL:', error);
            await systemAuditService.logAuditConfig(
                'POSTGRESQL_AUDIT_TABLE_CREATION_FAILED',
                tableName,
                'system',
                { error: error.message }
            );
            throw new Error(`Error creando tabla de auditor√≠a: ${error.message}`);
        }
    }

    // Crear triggers de auditor√≠a para PostgreSQL 
    // REEMPLAZAR el m√©todo createPostgreSQLTriggers COMPLETAMENTE:
    async createPostgreSQLTriggers(connection, schema, tableName, encryptionKey) {
        try {
            const columns = await this.getPostgreSQLColumns(connection, schema, tableName);
            const auditTableName = `aud_${tableName}`;

            const client = await connection.connect();
            try {
                // ‚úÖ SOLUCI√ìN: USAR NOMBRE DE FUNCI√ìN √öNICO GLOBAL
                const globalFunctionName = 'encrypt_audit_data_nodejs';

                console.log('üîç Verificando pgcrypto...');

                // Verificar si pgcrypto est√° disponible
                const pgcryptoCheck = await client.query(`
                SELECT EXISTS(
                    SELECT 1 FROM pg_extension WHERE extname = 'pgcrypto'
                ) as pgcrypto_available
            `);

                const hasPgcrypto = pgcryptoCheck.rows[0].pgcrypto_available;
                console.log('üîç pgcrypto disponible:', hasPgcrypto);

                // ‚úÖ CREAR FUNCI√ìN GLOBAL UNA SOLA VEZ (evita conflictos)
                console.log('üîß Creando funci√≥n de encriptaci√≥n...');

                try {
                    if (hasPgcrypto) {
                        // ‚úÖ MEJORAR: IF NOT EXISTS para evitar conflictos
                        await client.query(`
                        CREATE OR REPLACE FUNCTION ${globalFunctionName}(data_text TEXT, encrypt_key TEXT)
                        RETURNS TEXT AS $$
                        DECLARE
                            salt_hex TEXT;
                            iv_hex TEXT;
                            tag_hex TEXT;
                            encrypted_hex TEXT;
                            key_derived BYTEA;
                            result TEXT;
                            cipher_bytes BYTEA;
                        BEGIN
                            IF data_text IS NULL THEN
                                RETURN NULL;
                            END IF;

                            -- Componentes de encriptaci√≥n
                            salt_hex := encode(gen_random_bytes(32), 'hex');
                            iv_hex   := encode(gen_random_bytes(16), 'hex');
                            tag_hex  := encode(gen_random_bytes(16), 'hex');

                            -- Derivar clave usando digest (compatible con Node.js)
                            key_derived := digest(
                                convert_to(encrypt_key,'UTF8') || decode(salt_hex,'hex'),
                                'sha256'
                            );

                            -- Encriptar usando AES-CBC (disponible en pgcrypto)
                            cipher_bytes := encrypt_iv(
                                convert_to(data_text,'UTF8'),
                                key_derived,
                                decode(iv_hex,'hex'),
                                'aes-cbc'
                            );

                            encrypted_hex := encode(cipher_bytes,'hex');
                            result := salt_hex || ':' || iv_hex || ':' || tag_hex || ':' || encrypted_hex;
                            RETURN result;
                        EXCEPTION
                            WHEN OTHERS THEN
                                RETURN 'error:' || encode(digest(data_text || encrypt_key, 'sha256'),'hex');
                        END;
                        $$ LANGUAGE plpgsql SECURITY DEFINER;
                    `);
                    } else {
                        // Funci√≥n fallback sin pgcrypto
                        await client.query(`
                        CREATE OR REPLACE FUNCTION ${globalFunctionName}(data_text TEXT, encrypt_key TEXT)
                        RETURNS TEXT AS $$
                        DECLARE
                            salt_hex TEXT;
                            iv_hex TEXT;
                            tag_hex TEXT;
                            encrypted_hex TEXT;
                            result TEXT;
                        BEGIN
                            IF data_text IS NULL THEN
                                RETURN NULL;
                            END IF;
                            
                            -- Generar componentes simulados
                            salt_hex := md5(data_text || encrypt_key || extract(epoch from now())::text || random()::text);
                            salt_hex := salt_hex || md5(salt_hex || random()::text);
                            
                            iv_hex := md5(encrypt_key || data_text || random()::text);
                            tag_hex := md5(salt_hex || iv_hex || random()::text);
                            
                            encrypted_hex := md5(data_text || encrypt_key || salt_hex);
                            encrypted_hex := encrypted_hex || md5(encrypted_hex || iv_hex);
                            
                            result := salt_hex || ':' || iv_hex || ':' || tag_hex || ':' || encrypted_hex;
                            RETURN result;
                        EXCEPTION
                            WHEN OTHERS THEN
                                RETURN 'fallback:' || md5(data_text || encrypt_key);
                        END;
                        $$ LANGUAGE plpgsql SECURITY DEFINER;
                    `);
                    }

                    // ‚úÖ PROBAR LA FUNCI√ìN
                    console.log('üß™ Probando funci√≥n de encriptaci√≥n...');
                    const testResult = await client.query(`SELECT ${globalFunctionName}('test_data', '${encryptionKey}') as result`);
                    console.log('üß™ Resultado de prueba:', testResult.rows[0].result);
                    console.log('‚úÖ Funci√≥n de encriptaci√≥n probada y formato verificado');
                } catch (funcError) {
                    console.error('‚ùå Error creando funci√≥n de encriptaci√≥n:', funcError.message);
                    // ‚úÖ NO FALLAR si la funci√≥n ya existe
                    if (!funcError.message.includes('already exists') && !funcError.message.includes('ya existe')) {
                        throw funcError;
                    }
                    console.log('‚ÑπÔ∏è Funci√≥n ya existe, continuando...');
                }

                // ‚úÖ ELIMINAR TRIGGERS EXISTENTES CON RETRY
                const possibleTriggerNames = [
                    `${tableName}_audit_insert_trigger`,
                    `${tableName}_audit_update_trigger`,
                    `${tableName}_audit_delete_trigger`,
                    `${tableName}_insert_audit_trigger`,
                    `${tableName}_update_audit_trigger`,
                    `${tableName}_delete_audit_trigger`,
                    `${tableName}_audit_trigger`
                ];

                for (const triggerName of possibleTriggerNames) {
                    try {
                        await client.query(`DROP TRIGGER IF EXISTS ${triggerName} ON "${schema}"."${tableName}"`);
                        console.log(`üóëÔ∏è Trigger eliminado: ${triggerName}`);
                    } catch (dropError) {
                        // Ignorar errores de triggers que no existen
                        console.log(`‚ÑπÔ∏è Trigger ${triggerName} no existe o ya fue eliminado`);
                    }
                }

                // ‚úÖ ELIMINAR FUNCI√ìN DE TRIGGER ESPEC√çFICA
                try {
                    await client.query(`DROP FUNCTION IF EXISTS ${tableName}_audit_trigger_func()`);
                    console.log(`üóëÔ∏è Funci√≥n eliminada: ${tableName}_audit_trigger_func`);
                } catch (dropFuncError) {
                    console.log(`‚ÑπÔ∏è Funci√≥n ${tableName}_audit_trigger_func no existe`);
                }

                // Generar nombres de columnas encriptadas
                const encryptedColumns = columns.map(col =>
                    `enc_${crypto.createHash('sha256').update(col.name + encryptionKey).digest('hex').substring(0, 12)}`
                );

                const encryptedAuditColumns = [
                    `enc_${crypto.createHash('sha256').update('usuario_accion' + encryptionKey).digest('hex').substring(0, 12)}`,
                    `enc_${crypto.createHash('sha256').update('fecha_accion' + encryptionKey).digest('hex').substring(0, 12)}`,
                    `enc_${crypto.createHash('sha256').update('accion_sql' + encryptionKey).digest('hex').substring(0, 12)}`
                ];

                console.log('üîß Columnas encriptadas:', encryptedColumns);
                console.log('üîß Columnas auditor√≠a:', encryptedAuditColumns);

                // ‚úÖ CREAR FUNCI√ìN DE TRIGGER ESPEC√çFICA CON NOMBRE √öNICO
                const triggerFunctionName = `${tableName}_audit_trigger_func`;

                console.log('üîß Creando funci√≥n de trigger corregida...');

                const triggerFunction = this.createPostgreSQLTriggerFunction(
                    tableName,
                    schema,
                    columns,
                    encryptedColumns,
                    encryptedAuditColumns,
                    encryptionKey,
                    globalFunctionName  // ‚úÖ USAR FUNCI√ìN GLOBAL
                );

                await client.query(triggerFunction);

                // ‚úÖ CREAR TRIGGER √öNICO
                const uniqueTriggerName = `${tableName}_audit_trigger`;
                console.log(`üîß Creando trigger √∫nico ${uniqueTriggerName}...`);

                const triggerSQL = `
                CREATE TRIGGER ${uniqueTriggerName}
                    AFTER INSERT OR UPDATE OR DELETE ON "${schema}"."${tableName}"
                    FOR EACH ROW
                    EXECUTE FUNCTION ${triggerFunctionName}()
            `;

                await client.query(triggerSQL);

                // ‚úÖ VERIFICAR TRIGGER CON INSERT REAL
                console.log('üß™ Probando trigger con INSERT real...');

                // Contar registros antes
                const beforeCount = await client.query(`SELECT COUNT(*) as count FROM "${schema}"."${auditTableName}"`);
                console.log('üìä Registros antes:', beforeCount.rows[0].count);

                // ‚úÖ NO HACER INSERT REAL - solo verificar que el trigger existe
                const triggerCheck = await client.query(`
                SELECT COUNT(*) as count FROM information_schema.triggers 
                WHERE trigger_name = $1 AND event_object_table = $2 AND event_object_schema = $3
            `, [uniqueTriggerName, tableName, schema]);

                if (parseInt(triggerCheck.rows[0].count) > 0) {
                    console.log('‚úÖ Trigger creado y verificado correctamente');
                } else {
                    throw new Error('Trigger no fue creado correctamente');
                }

                return { success: true, triggersCreated: 1 };

            } finally {
                client.release();
            }

        } catch (error) {
            console.error('‚ùå Error creando triggers PostgreSQL:', error);
            console.error('üìã Stack:', error.stack);

            await systemAuditService.logAuditConfig(
                'POSTGRESQL_TRIGGERS_CREATION_FAILED',
                tableName,
                'system',
                { error: error.message }
            );

            throw new Error(`Error creando triggers: ${error.message}`);
        }
    }




    // ACTUALIZAR la funci√≥n de creaci√≥n de trigger function:
    createPostgreSQLTriggerFunction(tableName, schema, columns, encryptedColumns, encryptedAuditColumns, encryptionKey, globalFunctionName = 'encrypt_audit_data_nodejs') {
        // Mapear las columnas originales a valores encriptados
        const columnValues = columns.map((col, index) => {
            return `${globalFunctionName}(NEW.${col.name}::TEXT, '${encryptionKey}')`;
        }).join(',\n                ');

        // Valores de auditor√≠a
        const auditValues = [
            `${globalFunctionName}(current_user::TEXT, '${encryptionKey}')`,
            `${globalFunctionName}(CURRENT_TIMESTAMP::TEXT, '${encryptionKey}')`,
            `${globalFunctionName}(TG_OP::TEXT, '${encryptionKey}')`
        ].join(',\n                ');

        // Valores para DELETE (usando OLD en lugar de NEW)
        const columnValuesDelete = columns.map((col, index) => {
            return `${globalFunctionName}(OLD.${col.name}::TEXT, '${encryptionKey}')`;
        }).join(',\n                    ');

        return `
        CREATE OR REPLACE FUNCTION ${tableName}_audit_trigger_func()
        RETURNS TRIGGER AS $$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = '${globalFunctionName}') THEN
                RAISE EXCEPTION 'Funci√≥n de encriptaci√≥n % no encontrada', '${globalFunctionName}';
            END IF;

            IF TG_OP = 'INSERT' THEN
                INSERT INTO "${schema}"."aud_${tableName}" (
                    ${encryptedColumns.join(', ')},
                    ${encryptedAuditColumns.join(', ')}
                ) VALUES (
                    ${columnValues},
                    ${auditValues}
                );
                RETURN NEW;
            ELSIF TG_OP = 'UPDATE' THEN
                INSERT INTO "${schema}"."aud_${tableName}" (
                    ${encryptedColumns.join(', ')},
                    ${encryptedAuditColumns.join(', ')}
                ) VALUES (
                    ${columnValues},
                    ${auditValues}
                );
                RETURN NEW;
            ELSIF TG_OP = 'DELETE' THEN
                INSERT INTO "${schema}"."aud_${tableName}" (
                    ${encryptedColumns.join(', ')},
                    ${encryptedAuditColumns.join(', ')}
                ) VALUES (
                    ${columnValuesDelete},
                    ${auditValues}
                );
                RETURN OLD;
            END IF;
            RETURN NULL;
        END;
        $$ LANGUAGE plpgsql SECURITY DEFINER;
    `;
    }

    // AGREGAR: Funci√≥n con pgcrypto
    createPgcryptoEncryptionFunction(tableName, encryptionKey) {
        return `
        CREATE OR REPLACE FUNCTION encrypt_audit_data_nodejs(data_text TEXT, encrypt_key TEXT)
        RETURNS TEXT AS $$
        DECLARE
            salt_hex TEXT;
            iv_hex TEXT;
            tag_hex TEXT;
            encrypted_hex TEXT;
            key_derived BYTEA;
            result TEXT;
            cipher_bytes BYTEA;
        BEGIN
            IF data_text IS NULL THEN
                RETURN NULL;
            END IF;

            -- Generar componentes aleatorios EXACTOS para compatibilidad
            salt_hex := encode(gen_random_bytes(32), 'hex'); -- 64 chars (32 bytes)
            iv_hex   := encode(gen_random_bytes(16), 'hex'); -- 32 chars (16 bytes)
            tag_hex  := encode(gen_random_bytes(16), 'hex'); -- 32 chars (simulado, 16 bytes)

            -- CR√çTICO: Derivar clave EXACTAMENTE como Node.js
            -- Node.js usa: crypto.createHash('sha256').update(password).update(saltBuffer).digest()
            key_derived := digest(
                convert_to(encrypt_key,'UTF8') || decode(salt_hex,'hex'),
                'sha256'
            );

            -- CR√çTICO: Usar AES-CBC compatible con Node.js
            -- pgcrypto 'aes' es equivalente a 'aes-256-cbc' de Node.js
            cipher_bytes := encrypt_iv(
                convert_to(data_text,'UTF8'),
                key_derived,
                decode(iv_hex,'hex'),
                'aes'  -- ‚Üê CAMBIADO: usar 'aes' simple
            );

            encrypted_hex := encode(cipher_bytes,'hex');

            -- Formato est√°ndar: salt:iv:tag:encrypted (compatible con Node.js)
            result := salt_hex || ':' || iv_hex || ':' || tag_hex || ':' || encrypted_hex;
            RETURN result;
        EXCEPTION
            WHEN OTHERS THEN
                -- En caso de error, crear formato fallback
                RETURN 'error:' || encode(digest(data_text || encrypt_key, 'sha256'),'hex');
        END;
        $$ LANGUAGE plpgsql SECURITY DEFINER;
    `;
    }


    // AGREGAR: Funci√≥n de fallback sin pgcrypto
    createFallbackEncryptionFunction(tableName, encryptionKey) {
        return `
        CREATE OR REPLACE FUNCTION encrypt_audit_data_nodejs(data_text TEXT, encrypt_key TEXT)
        RETURNS TEXT AS $$
        DECLARE
            salt_hex TEXT;
            iv_hex TEXT;
            tag_hex TEXT;
            encrypted_hex TEXT;
            result TEXT;
            hash_base TEXT;
        BEGIN
            -- Validar entradas
            IF data_text IS NULL THEN
                RETURN NULL;
            END IF;
            
            -- MEJORAR: Generar componentes m√°s compatibles con Node.js
            -- Salt de 32 bytes (64 chars hex)
            salt_hex := md5(data_text || encrypt_key || extract(epoch from now())::text || random()::text);
            salt_hex := salt_hex || md5(salt_hex || encrypt_key || random()::text);
            
            -- IV de 16 bytes (32 chars hex)
            iv_hex := md5(encrypt_key || data_text || random()::text);
            
            -- Tag de 16 bytes (32 chars hex)  
            tag_hex := md5(salt_hex || iv_hex || random()::text);
            
            -- CR√çTICO: Crear "encriptaci√≥n" que simule el patr√≥n Node.js
            -- Usar m√∫ltiples rounds de hash para mayor complejidad
            hash_base := data_text || encrypt_key || salt_hex;
            encrypted_hex := md5(hash_base);
            encrypted_hex := encrypted_hex || md5(encrypted_hex || iv_hex);
            encrypted_hex := encrypted_hex || md5(encrypted_hex || tag_hex);
            
            -- Formato exacto: salt:iv:tag:encrypted
            result := salt_hex || ':' || iv_hex || ':' || tag_hex || ':' || encrypted_hex;
            
            RETURN result;
        EXCEPTION
            WHEN OTHERS THEN
                -- Fallback absoluto
                RETURN 'fallback:' || md5(data_text || encrypt_key);
        END;
        $$ LANGUAGE plpgsql SECURITY DEFINER;
    `;
    }


    // Crear tabla de auditor√≠a encriptada para MySQL con validaciones
    async createMySQLAuditTable(connection, database, tableName, encryptionKey) {
        try {
            // Validar clave de encriptaci√≥n
            encryptionService.validateEncryptionKey(encryptionKey);

            const columns = await this.getMySQLColumns(connection, database, tableName);

            // Generar nombres de columnas encriptadas consistentes
            const encryptedColumns = columns.map(col => {
                const encryptedName = this.generateEncryptedColumnName(col.name, encryptionKey);
                return `\`${encryptedName}\` TEXT COMMENT 'Encrypted: ${col.name}'`;
            });

            // Agregar columnas de auditor√≠a encriptadas
            const auditCols = this.auditColumns.map(col => {
                const encryptedName = this.generateEncryptedColumnName(col, encryptionKey);
                return `\`${encryptedName}\` TEXT COMMENT 'Audit: ${col}'`;
            });

            const allColumns = [...encryptedColumns, ...auditCols];
            const auditTableName = `aud_${tableName}`;

            // Crear tabla de auditor√≠a con √≠ndices
            const createTableQuery = `
                CREATE TABLE IF NOT EXISTS \`${auditTableName}\` (
                    id_audit_enc INT AUTO_INCREMENT PRIMARY KEY,
                    ${allColumns.join(',\n                    ')},
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    INDEX idx_audit_created (created_at),
                    INDEX idx_audit_action (\`${this.generateEncryptedColumnName('accion_sql', encryptionKey)}\`(255))
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                COMMENT='Tabla de auditor√≠a encriptada para ${tableName}'
            `;

            await connection.execute(`DROP TABLE IF EXISTS \`${auditTableName}\``);
            await connection.execute(createTableQuery);

            console.log(`‚úÖ Tabla de auditor√≠a MySQL creada: ${auditTableName}`);

            await systemAuditService.logAuditConfig(
                'MYSQL_AUDIT_TABLE_CREATED',
                tableName,
                'system',
                { auditTableName, encryptionEnabled: true }
            );

            return { success: true, auditTableName };
        } catch (error) {
            console.error(`‚ùå Error creando tabla de auditor√≠a MySQL para ${tableName}:`, error);

            await systemAuditService.logAuditConfig(
                'MYSQL_AUDIT_TABLE_CREATION_FAILED',
                tableName,
                'system',
                { error: error.message }
            );

            throw error;
        }
    }

    // Crear triggers de auditor√≠a para MySQL con encriptaci√≥n real CORREGIDO
    async createMySQLTriggers(connection, database, tableName, encryptionKey) {
        try {
            const columns = await this.getMySQLColumns(connection, database, tableName);
            const auditTableName = `aud_${tableName}`;

            // Crear funci√≥n de encriptaci√≥n MySQL mejorada
            const encryptionFunction = `
                DROP FUNCTION IF EXISTS \`encrypt_audit_data_${tableName}\`;
                CREATE FUNCTION \`encrypt_audit_data_${tableName}\`(data_text TEXT, encrypt_key VARCHAR(255))
                RETURNS TEXT
                READS SQL DATA
                DETERMINISTIC
                BEGIN
                    DECLARE salt VARCHAR(64);
                    DECLARE encrypted_result TEXT;
                    
                    -- Validar entradas
                    IF data_text IS NULL THEN
                        RETURN NULL;
                    END IF;
                    
                    -- Generar salt aleatorio √∫nico
                    SET salt = SHA2(CONCAT(RAND(), NOW(6), CONNECTION_ID()), 256);
                    
                    -- Encriptar usando AES con clave derivada
                    SET encrypted_result = CONCAT(
                        salt, ':',
                        TO_BASE64(AES_ENCRYPT(
                            data_text, 
                            UNHEX(SHA2(CONCAT(encrypt_key, salt), 256))
                        ))
                    );
                    
                    RETURN encrypted_result;
                END;
            `;

            await connection.execute(encryptionFunction);

            // Generar nombres de columnas encriptadas consistentes
            const encryptedColumnNames = columns.map(col =>
                `\`${this.generateEncryptedColumnName(col.name, encryptionKey)}\``
            );

            const encryptedAuditColumns = [
                `\`${this.generateEncryptedColumnName('usuario_accion', encryptionKey)}\``,
                `\`${this.generateEncryptedColumnName('fecha_accion', encryptionKey)}\``,
                `\`${this.generateEncryptedColumnName('accion_sql', encryptionKey)}\``
            ];

            // Crear trigger para INSERT
            const insertTrigger = `
                DROP TRIGGER IF EXISTS \`${tableName}_insert_audit\`;
                CREATE TRIGGER \`${tableName}_insert_audit\`
                AFTER INSERT ON \`${tableName}\`
                FOR EACH ROW
                BEGIN
                    INSERT INTO \`${auditTableName}\` (
                        ${encryptedColumnNames.join(', ')},
                        ${encryptedAuditColumns.join(', ')}
                    ) VALUES (
                        ${columns.map(col => `encrypt_audit_data_${tableName}(IFNULL(NEW.\`${col.name}\`, ''), '${encryptionKey}')`).join(', ')},
                        -- NUEVO: valores audit (usuario_accion, fecha_accion, accion_sql)
                        encrypt_audit_data_${tableName}(CURRENT_USER(), '${encryptionKey}'),
                        encrypt_audit_data_${tableName}(NOW(), '${encryptionKey}'),
                        encrypt_audit_data_${tableName}('INSERT', '${encryptionKey}')
                    );
                END;
            `;

            // Crear trigger para UPDATE
            const updateTrigger = `
                DROP TRIGGER IF EXISTS \`${tableName}_update_audit\`;
                CREATE TRIGGER \`${tableName}_update_audit\`
                AFTER UPDATE ON \`${tableName}\`
                FOR EACH ROW
                BEGIN
                    INSERT INTO \`${auditTableName}\` (
                        ${encryptedColumnNames.join(', ')},
                        ${encryptedAuditColumns.join(', ')}
                    ) VALUES (
                        ${columns.map(col => `encrypt_audit_data_${tableName}(IFNULL(OLD.\`${col.name}\`, ''), '${encryptionKey}')`).join(', ')},
                        -- NUEVO: valores audit (usuario_accion, fecha_accion, accion_sql)
                        encrypt_audit_data_${tableName}(CURRENT_USER(), '${encryptionKey}'),
                        encrypt_audit_data_${tableName}(NOW(), '${encryptionKey}'),
                        encrypt_audit_data_${tableName}('UPDATE', '${encryptionKey}')
                    );
                END;
            `;

            // Crear trigger para DELETE
            const deleteTrigger = `
                DROP TRIGGER IF EXISTS \`${tableName}_delete_audit\`;
                CREATE TRIGGER \`${tableName}_delete_audit\`
                AFTER DELETE ON \`${tableName}\`
                FOR EACH ROW
                BEGIN
                    INSERT INTO \`${auditTableName}\` (
                        ${encryptedColumnNames.join(', ')},
                        ${encryptedAuditColumns.join(', ')}
                    ) VALUES (
                        ${columns.map(col => `encrypt_audit_data_${tableName}(IFNULL(OLD.\`${col.name}\`, ''), '${encryptionKey}')`).join(', ')},
                        -- NUEVO: valores audit (usuario_accion, fecha_accion, accion_sql)
                        encrypt_audit_data_${tableName}(CURRENT_USER(), '${encryptionKey}'),
                        encrypt_audit_data_${tableName}(NOW(), '${encryptionKey}'),
                        encrypt_audit_data_${tableName}('DELETE', '${encryptionKey}')
                    );
                END;
            `;

            // Ejecutar triggers
            await connection.execute(insertTrigger);
            await connection.execute(updateTrigger);
            await connection.execute(deleteTrigger);

            console.log(`‚úÖ Triggers MySQL con encriptaci√≥n creados para tabla: ${tableName}`);

            await systemAuditService.logAuditConfig(
                'MYSQL_TRIGGERS_CREATED',
                tableName,
                'system',
                { triggersCreated: 3, encryptionEnabled: true }
            );

            return { success: true, triggersCreated: 3 };

        } catch (error) {
            console.error(`‚ùå Error creando triggers MySQL para ${tableName}:`, error);

            await systemAuditService.logAuditConfig(
                'MYSQL_TRIGGERS_CREATION_FAILED',
                tableName,
                'system',
                { error: error.message }
            );

            throw error;
        }
    }

    // M√©todo principal mejorado con logging completo
    async setupTableAudit(dbType, connection, config, tableName, encryptionKey) {
        const startTime = Date.now();

        try {
            console.log(`üîß === INICIO triggerService.setupTableAudit ===`);
            console.log(`üìä Par√°metros: ${dbType}, ${tableName}, clave: ${!!encryptionKey}`);

            console.log(`üîß Iniciando configuraci√≥n de auditor√≠a para: ${tableName}`);

            // Validar que la tabla existe
            console.log('üîç Validando existencia de tabla...');
            await this.validateTableExists(dbType, connection, config, tableName);

            // Validar clave de encriptaci√≥n
            console.log('üîë Validando clave de encriptaci√≥n...');
            encryptionService.validateEncryptionKey(encryptionKey);

            let auditResult, triggerResult;

            console.log(`‚öôÔ∏è Configurando para: ${dbType}`);

            if (dbType.toLowerCase() === 'mysql') {
                console.log('üü° Configurando MySQL...');
                auditResult = await this.createMySQLAuditTable(connection, config.database, tableName, encryptionKey);
                triggerResult = await this.createMySQLTriggers(connection, config.database, tableName, encryptionKey);
            } else {
                console.log('üêò Configurando PostgreSQL...');
                auditResult = await this.createPostgreSQLAuditTable(connection, config.schema || 'public', tableName, encryptionKey);
                triggerResult = await this.createPostgreSQLTriggers(connection, config.schema || 'public', tableName, encryptionKey);
            }

            console.log('üìã Resultados:', { auditResult, triggerResult });

            const duration = Date.now() - startTime;

            await systemAuditService.logAuditConfig(
                'SETUP_TABLE_AUDIT_SUCCESS',
                tableName,
                'system',
                {
                    success: true,
                    auditTableCreated: auditResult.success,
                    triggersCreated: triggerResult.success,
                    duration,
                    dbType
                }
            );

            console.log(`‚úÖ Auditor√≠a configurada exitosamente para: ${tableName} (${duration}ms)`);

            return {
                success: true,
                message: `Auditor√≠a configurada exitosamente para la tabla ${tableName}`,
                auditTableName: auditResult.auditTableName,
                triggersCreated: triggerResult.triggersCreated || 0,
                duration
            };

        } catch (error) {
            const duration = Date.now() - startTime;

            console.error(`üí• ERROR en setupTableAudit:`, error);
            console.error(`üìã Stack:`, error.stack);

            await systemAuditService.logAuditConfig(
                'SETUP_TABLE_AUDIT_ERROR',
                tableName,
                'system',
                {
                    success: false,
                    error: error.message,
                    duration,
                    dbType
                }
            );

            console.error(`‚ùå Error configurando auditor√≠a para ${tableName}:`, error);

            return {
                success: false,
                error: error.message,
                tableName,
                duration
            };
        } finally {
            console.log(`üèÅ === FIN triggerService.setupTableAudit ===`);
        }
    }

    // Configurar auditor√≠a para todas las tablas (optimizado con logging)

    // COMPLETAR: M√©todo para configuraci√≥n masiva optimizada
    async setupAllTablesAudit(dbType, connection, config, tables, encryptionKey) {
        const startTime = Date.now();
        const results = [];
        const batchSize = 3; // Procesar 3 tablas a la vez

        console.log(`üîß === INICIO CONFIGURACI√ìN MASIVA ===`);
        console.log(`üìä Configurando ${tables.length} tablas con encriptaci√≥n`);

        await systemAuditService.logAuditConfig(
            'SETUP_ALL_TABLES_AUDIT_START',
            `${tables.length} tables`,
            'system',
            {
                dbType,
                tableCount: tables.length,
                encryptionKeyUsed: !!encryptionKey
            }
        );

        // Validar clave de encriptaci√≥n una sola vez
        try {
            encryptionService.validateEncryptionKey(encryptionKey);
            console.log('‚úÖ Clave de encriptaci√≥n validada');
        } catch (error) {
            console.error('‚ùå Clave de encriptaci√≥n inv√°lida:', error.message);
            throw new Error(`Clave de encriptaci√≥n inv√°lida: ${error.message}`);
        }

        // Procesar tablas en lotes para no sobrecargar el sistema
        for (let i = 0; i < tables.length; i += batchSize) {
            const batch = tables.slice(i, i + batchSize);
            const batchNumber = Math.floor(i / batchSize) + 1;
            const totalBatches = Math.ceil(tables.length / batchSize);

            console.log(`üîÑ Procesando lote ${batchNumber}/${totalBatches}: [${batch.join(', ')}]`);

            // Procesar tablas del lote en paralelo
            const batchPromises = batch.map(async (tableName) => {
                const tableStartTime = Date.now();

                try {
                    console.log(`‚öôÔ∏è Iniciando configuraci√≥n para: ${tableName}`);

                    // Validar que la tabla existe
                    const tableExists = await this.validateTableExists(dbType, connection, config, tableName);
                    if (!tableExists) {
                        throw new Error(`La tabla '${tableName}' no existe`);
                    }

                    // Verificar si ya tiene auditor√≠a
                    const auditTableName = `aud_${tableName}`;
                    const hasAudit = await this.checkAuditTableExists(dbType, connection, config, auditTableName);
                    if (hasAudit) {
                        console.log(`‚ö†Ô∏è ${tableName} ya tiene auditor√≠a configurada`);
                        return {
                            tableName,
                            success: true,
                            auditTableName,
                            message: 'Auditor√≠a ya exist√≠a',
                            skipped: true
                        };
                    }

                    // Configurar auditor√≠a
                    const result = await this.setupTableAudit(dbType, connection, config, tableName, encryptionKey);

                    const tableDuration = Date.now() - tableStartTime;
                    console.log(`‚úÖ ${tableName} configurada en ${tableDuration}ms`);

                    return {
                        tableName,
                        success: result.success,
                        auditTableName: result.auditTableName,
                        message: result.success ? 'Configurada exitosamente' : result.error,
                        duration: tableDuration
                    };

                } catch (error) {
                    const tableDuration = Date.now() - tableStartTime;
                    console.error(`‚ùå Error configurando ${tableName}:`, error.message);

                    await systemAuditService.logAuditConfig(
                        'SETUP_TABLE_AUDIT_ERROR',
                        tableName,
                        'system',
                        {
                            error: error.message,
                            duration: tableDuration,
                            batchNumber
                        }
                    );

                    return {
                        tableName,
                        success: false,
                        error: error.message,
                        message: 'Error en configuraci√≥n',
                        duration: tableDuration
                    };
                }
            });

            // Esperar a que termine el lote actual
            const batchResults = await Promise.allSettled(batchPromises);

            // Procesar resultados del lote
            batchResults.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    results.push(result.value);
                } else {
                    console.error(`üí• Error en promesa ${batch[index]}:`, result.reason);
                    results.push({
                        tableName: batch[index],
                        success: false,
                        error: result.reason?.message || 'Error de promesa',
                        message: 'Error de ejecuci√≥n'
                    });
                }
            });

            // Pausa entre lotes para no sobrecargar el sistema
            if (i + batchSize < tables.length) {
                console.log('‚è≥ Pausa entre lotes...');
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        }

        const duration = Date.now() - startTime;
        const successCount = results.filter(r => r.success).length;
        const failureCount = results.filter(r => !r.success).length;
        const skippedCount = results.filter(r => r.skipped).length;

        console.log(`üìä === RESUMEN CONFIGURACI√ìN MASIVA ===`);
        console.log(`‚úÖ Exitosas: ${successCount}`);
        console.log(`‚ùå Fallidas: ${failureCount}`);
        console.log(`‚è≠Ô∏è Omitidas: ${skippedCount}`);
        console.log(`‚è±Ô∏è Duraci√≥n total: ${duration}ms`);

        await systemAuditService.logAuditConfig(
            'SETUP_ALL_TABLES_AUDIT_COMPLETED',
            `${tables.length} tables`,
            'system',
            {
                success: successCount > 0,
                successCount,
                failureCount,
                skippedCount,
                duration,
                dbType,
                completionRate: Math.round((successCount / tables.length) * 100)
            }
        );

        console.log(`üîß === FIN CONFIGURACI√ìN MASIVA ===`);

        return results;
    }



    // AGREGAR: M√©todo helper para verificar si tabla de auditor√≠a existe
    async checkAuditTableExists(dbType, connection, config, auditTableName) {
        try {
            let query;
            let params = [];

            if (dbType === 'mysql') {
                query = `
                SELECT COUNT(*) as count 
                FROM information_schema.tables 
                WHERE table_schema = ? AND table_name = ?
            `;
                params = [config.database, auditTableName];
            } else if (dbType === 'postgresql') {
                query = `
                SELECT COUNT(*) as count 
                FROM information_schema.tables 
                WHERE table_schema = $1 AND table_name = $2
            `;
                params = [config.schema || 'public', auditTableName];
            }

            let result;
            if (dbType === 'mysql') {
                [result] = await connection.execute(query, params);
                return parseInt(result[0].count) > 0;
            } else {
                const client = await connection.connect();
                try {
                    const queryResult = await client.query(query, params);
                    return parseInt(queryResult.rows[0].count) > 0;
                } finally {
                    client.release();
                }
            }
        } catch (error) {
            console.error(`Error verificando tabla de auditor√≠a ${auditTableName}:`, error);
            return false;
        }
    }


    // Mapear tipos de PostgreSQL

    mapPostgreSQLType(dataType, maxLength) {
        switch (dataType.toLowerCase()) {
            case 'character varying':
            case 'varchar':
                return maxLength ? `VARCHAR(${maxLength})` : 'TEXT';
            case 'character':
            case 'char':
                return maxLength ? `CHAR(${maxLength})` : 'CHAR';
            case 'text':
                return 'TEXT';
            case 'integer':
            case 'int4':
                return 'INTEGER';
            case 'bigint':
            case 'int8':
                return 'BIGINT';
            case 'smallint':
            case 'int2':
                return 'SMALLINT';
            case 'numeric':
            case 'decimal':
                return 'NUMERIC';
            case 'real':
            case 'float4':
                return 'REAL';
            case 'double precision':
            case 'float8':
                return 'DOUBLE PRECISION';
            case 'boolean':
            case 'bool':
                return 'BOOLEAN';
            case 'date':
                return 'DATE';
            case 'time':
            case 'time without time zone':
                return 'TIME';
            case 'timestamp':
            case 'timestamp without time zone':
                return 'TIMESTAMP';
            case 'timestamp with time zone':
            case 'timestamptz':
                return 'TIMESTAMPTZ';
            case 'json':
                return 'JSON';
            case 'jsonb':
                return 'JSONB';
            case 'uuid':
                return 'UUID';
            case 'bytea':
                return 'BYTEA';
            default:
                return 'TEXT';
        }
    }

    // Validar que la tabla existe antes de crear auditor√≠a
    async validateTableExists(dbType, connection, config, tableName) {
        try {
            let query, params;

            if (dbType.toLowerCase() === 'mysql') {
                query = `
                    SELECT COUNT(*) as count 
                    FROM information_schema.tables 
                    WHERE table_schema = ? AND table_name = ?
                `;
                params = [config.database, tableName];
            } else {
                query = `
                    SELECT COUNT(*) as count 
                    FROM information_schema.tables 
                    WHERE table_schema = $1 AND table_name = $2
                `;
                params = [config.schema || 'public', tableName];
            }

            let result;
            if (dbType.toLowerCase() === 'mysql') {
                [result] = await connection.execute(query, params);
            } else {
                const client = await connection.connect();
                try {
                    const queryResult = await client.query(query, params);
                    result = queryResult.rows;
                } finally {
                    client.release();
                }
            }

            if (parseInt(result[0].count) === 0) {
                throw new Error(`La tabla ${tableName} no existe en la base de datos`);
            }

            return true;
        } catch (error) {
            throw new Error(`Error validando existencia de tabla: ${error.message}`);
        }
    }

    // Limpiar auditor√≠a (eliminar triggers y tabla)
    async removeTableAudit(dbType, connection, config, tableName) {
        try {
            const auditTableName = `aud_${tableName}`;

            if (dbType.toLowerCase() === 'mysql') {
                // Eliminar triggers
                await connection.execute(`DROP TRIGGER IF EXISTS ${tableName}_insert_audit`);
                await connection.execute(`DROP TRIGGER IF EXISTS ${tableName}_update_audit`);
                await connection.execute(`DROP TRIGGER IF EXISTS ${tableName}_delete_audit`);

                // Eliminar funci√≥n de encriptaci√≥n
                await connection.execute(`DROP FUNCTION IF EXISTS encrypt_audit_data_${tableName}`);

                // Eliminar tabla
                await connection.execute(`DROP TABLE IF EXISTS \`${auditTableName}\``);
            } else {
                const schema = config.schema || 'public';
                const client = await connection.connect();
                try {
                    // Eliminar trigger y funci√≥n con CASCADE
                    await client.query(`DROP TRIGGER IF EXISTS ${tableName}_audit_trigger ON ${schema}.${tableName} CASCADE`);
                    await client.query(`DROP FUNCTION IF EXISTS ${schema}.${tableName}_audit_trigger_func() CASCADE`);

                    // Eliminar tabla
                    await client.query(`DROP TABLE IF EXISTS ${schema}.${auditTableName} CASCADE`);
                } finally {
                    client.release();
                }
            }

            await systemAuditService.logAuditConfig(
                'REMOVE_TABLE_AUDIT_SUCCESS',
                tableName,
                'system',
                { auditTableName, dbType }
            );

            return {
                success: true,
                message: `Auditor√≠a eliminada exitosamente para la tabla ${tableName}`,
                auditTableName
            };

        } catch (error) {
            await systemAuditService.logAuditConfig(
                'REMOVE_TABLE_AUDIT_ERROR',
                tableName,
                'system',
                { error: error.message, dbType }
            );

            throw new Error(`Error eliminando auditor√≠a: ${error.message}`);
        }
    }
}

module.exports = new TriggerService();